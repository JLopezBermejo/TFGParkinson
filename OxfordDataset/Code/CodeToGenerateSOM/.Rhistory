#inicializamos la red con la que entrenaremos
redInit <- somInit(dfScaled,10,10,"random")
#ahora entrenamos la red
G01SOM <- som(dfScaled, grid = somgrid(10,10,"hexagonal"), rlen = 1000,init = redInit)
#representamos la red
purple.fade <- function(n){
return(rgb(0,0,0.2,alpha=seq(0,1,1/n)))}
plot(G01SOM, type="count", shape = "straight", palette.name = purple.fade)
plot(G01SOM, type="dist.neighbours", shape = "straight")
#Vemos que clusters ha creado la red
distancesSOM <- dist(getCodes(G01SOM,1))
cluster <- hclust(distancesSOM)
plot(cluster,hang=-1,labels=F)
#ahora probamos que secciones crea para 2, 3 y 4 clusters
cluster2 <- cutree(cluster, k=2)
cluster3 <- cutree(cluster, k=3)
cluster4 <- cutree(cluster, k=4)
#representamos cada uno de ellos para estudiar si existen diferencias a la hora de hacer grupos
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1")[cluster2], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen")[cluster3], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen","red")[cluster4], shape = "straight")
rm(list = ls())
#cargamos los packetes
library(kohonen)
library(dplyr)
library(aweSOM)
#primeramente ir al directorio con los datos
directory <- paste(dirname(getwd()),'/GenerateGroups',sep='')
directory <- paste(directory,'/G01/G01_SC_22_10x10.csv',sep='')
#dependiendo de que grupo queramos utilizar cambiamos el comando anterior al grupo elegido
df <- read.csv(directory)
status <- df$status
name <- df$name
df <- select(df,-name)
df <- select(df,-status)
#se utiliza scale() para poder dimensionar bien el dataset y poder entrenar
dfScaled <- scale(df,center=T,scale=T)
#inicializamos la red con la que entrenaremos
redInit <- somInit(dfScaled,10,10,"random")
#ahora entrenamos la red
G01SOM <- som(dfScaled, grid = somgrid(10,10,"hexagonal"), rlen = 1000,init = redInit)
#representamos la red
purple.fade <- function(n){
return(rgb(0,0,0.2,alpha=seq(0,1,1/n)))}
plot(G01SOM, type="count", shape = "straight", palette.name = purple.fade)
plot(G01SOM, type="dist.neighbours", shape = "straight")
#Vemos que clusters ha creado la red
distancesSOM <- dist(getCodes(G01SOM,1))
cluster <- hclust(distancesSOM)
plot(cluster,hang=-1,labels=F)
#ahora probamos que secciones crea para 2, 3 y 4 clusters
cluster2 <- cutree(cluster, k=2)
cluster3 <- cutree(cluster, k=3)
cluster4 <- cutree(cluster, k=4)
#representamos cada uno de ellos para estudiar si existen diferencias a la hora de hacer grupos
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1")[cluster2], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen")[cluster3], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen","red")[cluster4], shape = "straight")
rm(list = ls())
#cargamos los packetes
library(kohonen)
library(dplyr)
library(aweSOM)
#primeramente ir al directorio con los datos
directory <- paste(dirname(getwd()),'/GenerateGroups',sep='')
directory <- paste(directory,'/G01/G01_SC_22_10x10.csv',sep='')
#dependiendo de que grupo queramos utilizar cambiamos el comando anterior al grupo elegido
df <- read.csv(directory)
status <- df$status
name <- df$name
df <- select(df,-name)
df <- select(df,-status)
#se utiliza scale() para poder dimensionar bien el dataset y poder entrenar
dfScaled <- scale(df,center=T,scale=T)
#inicializamos la red con la que entrenaremos
redInit <- somInit(dfScaled,10,10,"random")
#ahora entrenamos la red
G01SOM <- som(dfScaled, grid = somgrid(10,10,"hexagonal"), rlen = 1000,init = redInit)
#representamos la red
purple.fade <- function(n){
return(rgb(0,0,0.2,alpha=seq(0,1,1/n)))}
plot(G01SOM, type="count", shape = "straight", palette.name = purple.fade)
plot(G01SOM, type="dist.neighbours", shape = "straight")
#Vemos que clusters ha creado la red
distancesSOM <- dist(getCodes(G01SOM,1))
cluster <- hclust(distancesSOM)
plot(cluster,hang=-1,labels=F)
#ahora probamos que secciones crea para 2, 3 y 4 clusters
cluster2 <- cutree(cluster, k=2)
cluster3 <- cutree(cluster, k=3)
cluster4 <- cutree(cluster, k=4)
#representamos cada uno de ellos para estudiar si existen diferencias a la hora de hacer grupos
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1")[cluster2], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen")[cluster3], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen","red")[cluster4], shape = "straight")
directory <- paste(dirname(getwd()),'/GenerateGroups',sep='')
directory <- paste(directory,'/G01/G01_SC_22_10x10.csv',sep='')
#dependiendo de que grupo queramos utilizar cambiamos el comando anterior al grupo elegido
df <- read.csv(directory)
status <- df$status
name <- df$name
df <- select(df,-name)
#cargamos los packetes
library(kohonen)
library(dplyr)
library(aweSOM)
#primeramente ir al directorio con los datos
directory <- paste(dirname(getwd()),'/GenerateGroups',sep='')
directory <- paste(directory,'/G01/G01_SC_22_10x10.csv',sep='')
#dependiendo de que grupo queramos utilizar cambiamos el comando anterior al grupo elegido
df <- read.csv(directory)
status <- df$status
name <- df$name
df <- select(df,-name)
df <- select(df,-status)
set.seed(100)
#se utiliza scale() para poder dimensionar bien el dataset y poder entrenar
dfScaled <- scale(df,center=T,scale=T)
#inicializamos la red con la que entrenaremos
redInit <- somInit(dfScaled,10,10,"random")
#ahora entrenamos la red
G01SOM <- som(dfScaled, grid = somgrid(10,10,"hexagonal"), rlen = 1000,init = redInit)
#representamos la red
purple.fade <- function(n){
return(rgb(0,0,0.2,alpha=seq(0,1,1/n)))}
plot(G01SOM, type="count", shape = "straight", palette.name = purple.fade)
plot(G01SOM, type="dist.neighbours", shape = "straight")
#Vemos que clusters ha creado la red
distancesSOM <- dist(getCodes(G01SOM,1))
cluster <- hclust(distancesSOM)
plot(cluster,hang=-1,labels=F)
#ahora probamos que secciones crea para 2, 3 y 4 clusters
cluster2 <- cutree(cluster, k=2)
cluster3 <- cutree(cluster, k=3)
cluster4 <- cutree(cluster, k=4)
#representamos cada uno de ellos para estudiar si existen diferencias a la hora de hacer grupos
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1")[cluster2], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen")[cluster3], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen","red")[cluster4], shape = "straight")
rm(list = ls())
#cargamos los packetes
library(kohonen)
library(dplyr)
library(aweSOM)
#primeramente ir al directorio con los datos
directory <- paste(dirname(getwd()),'/GenerateGroups',sep='')
directory <- paste(directory,'/G01/G01_SC_22_10x10.csv',sep='')
#dependiendo de que grupo queramos utilizar cambiamos el comando anterior al grupo elegido
df <- read.csv(directory)
status <- df$status
name <- df$name
df <- select(df,-name)
df <- select(df,-status)
set.seed(23)
#se utiliza scale() para poder dimensionar bien el dataset y poder entrenar
dfScaled <- scale(df,center=T,scale=T)
#inicializamos la red con la que entrenaremos
redInit <- somInit(dfScaled,10,10,"random")
#ahora entrenamos la red
G01SOM <- som(dfScaled, grid = somgrid(10,10,"hexagonal"), rlen = 1000,init = redInit)
#representamos la red
purple.fade <- function(n){
return(rgb(0,0,0.2,alpha=seq(0,1,1/n)))}
plot(G01SOM, type="count", shape = "straight", palette.name = purple.fade)
plot(G01SOM, type="dist.neighbours", shape = "straight")
#Vemos que clusters ha creado la red
distancesSOM <- dist(getCodes(G01SOM,1))
cluster <- hclust(distancesSOM)
plot(cluster,hang=-1,labels=F)
#ahora probamos que secciones crea para 2, 3 y 4 clusters
cluster2 <- cutree(cluster, k=2)
cluster3 <- cutree(cluster, k=3)
cluster4 <- cutree(cluster, k=4)
#representamos cada uno de ellos para estudiar si existen diferencias a la hora de hacer grupos
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1")[cluster2], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen")[cluster3], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen","red")[cluster4], shape = "straight")
aux <- cbind(name,G01SOM$unit.classif)
print(aux)
aux <- cbind(aux,status)
print(aux)
provideDimnames(aux, sep = "", base = list("name","neurona","status"))
dimnames(aux)[[2]] <- c("neurona")
dimnames(aux)[2] <- c("neurona")
colnames(aux) <- c('name','neurona','status')
print(aux)
aux <- sort(aux$status)
View(aux)
unirCluster <- function(arrayUnir,gruposCluster){}
print(cluster2)
unirCluster <- function(arrayUnir,gruposCluster){
result <- arrayUnir
v <- c()
for(neurona in arrayUnir[['neurona']]){
aux = paste('V',neurona,sep='')
v <- append(v,c(arrayUnir[[aux]]))
}
result <-  cbind(result, v)
return(result)
}
unionClusters <- unirCluster(aux,cluster2)
print(aux)
unirCluster <- function(arrayUnir,gruposCluster){
result <- arrayUnir
v <- c()
for(neurona in arrayUnir[['neurona']]){
aux = paste('V',neurona,sep='')
v <- append(v,c(gruposCluster[[aux]]))
}
result <-  cbind(result, v)
return(result)
}
unionClusters <- unirCluster(aux,cluster2)
unirCluster <- function(arrayUnir,gruposCluster){
result <- arrayUnir
v <- c()
for(neurona in arrayUnir[[2]]){
aux = paste('V',neurona,sep='')
v <- append(v,c(gruposCluster[[aux]]))
}
result <-  cbind(result, v)
return(result)
}
unionClusters <- unirCluster(aux,cluster2)
unirCluster <- function(arrayUnir,gruposCluster){
result <- arrayUnir
v <- c()
for(neurona in arrayUnir[[2]]){
aux = paste('V',neurona,sep='')
v <- append(v,c(gruposCluster[aux]))
}
result <-  cbind(result, v)
return(result)
}
unionClusters <- unirCluster(aux,cluster2)
print(unionClusters)
unirCluster <- function(arrayUnir,gruposCluster){
result <- arrayUnir
v <- c()
for(neurona in arrayUnir[[2]]){
aux <- paste('V',neurona,sep='')
v <- append(v,c(gruposCluster[aux]))
}
result <-  cbind(result, v)
return(result)
}
unionClusters <- unirCluster(aux,cluster2)
print(unionClusters)
unirCluster <- function(arrayUnir,gruposCluster){
result <- arrayUnir
v <- c()
for(neurona in arrayUnir[[2]]){
aux <- paste('V',neurona,sep='')
print(gruposCluster[[aux]])
}
result <-  cbind(result, v)
return(result)
}
unionClusters <- unirCluster(aux,cluster2)
unirCluster <- function(arrayUnir,gruposCluster){
result <- arrayUnir
v <- c()
for(neurona in arrayUnir[[2]]){
aux <- paste('V',neurona,sep='')
print(aux)
}
result <-  cbind(result, v)
return(result)
}
unionClusters <- unirCluster(aux,cluster2)
print(aux)
print(arrayUnir[i])
unirCluster <- function(arrayUnir,gruposCluster){
result <- arrayUnir
v <- c()
for (i in length(arrayUnir)){
print(arrayUnir[i])
}
result <-  cbind(result, v)
return(result)
}
unionClusters <- unirCluster(aux,cluster2)
for (i in length(aux)){
print(aux[i])
}
matrizaux=as.data.frame(aux)
print(matrizaux)
for (i in length(matrizaux)){
print(matrizaux[i])
}
for (row in 1:nrow(matrizaux)){
print(row)
}
for (row in 1:nrow(matrizaux)){
print(matrizaux[row],'neurona')
}
for (row in 1:nrow(matrizaux)){
print(matrizaux[row,'neurona'])
}
matrizcluster2aux=as.data.frame(cluster2)
View(matrizcluster2aux)
for (row in 1:nrow(matrizcluster2aux)){
print(matrizcluster2aux[row])
}
for (row in matrizcluster2aux){
print(row)
}
print(matrizcluster2aux)
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(result)){
neur <- result[row,'neurona']
result[neur,nameVar] <- gruposCluster[neur]
}
return(result)
}
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(result)){
neur <- result[row,'neurona']
result[neur,nameVar] <- gruposCluster[neur,1]
}
return(result)
}
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
print(unionClusters)
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(result)){
neur <- result[row,'neurona']
print(neur)
result[neur,nameVar] <- gruposCluster[neur,'cluster2']
}
return(result)
}
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
print(unionClusters)
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(result)){
neur <- result[row,'neurona']
neur <- strtoi(neur)
result[neur,nameVar] <- gruposCluster[neur,'cluster2']
}
return(result)
}
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
print(unionClusters)
print(matrizcluster2aux)
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
print(unionClusters)
print(matrizcluster2aux[7,'cluster2'])
print(matrizcluster2aux[10,'cluster2'])
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(result)){
neur <- result[row,'neurona']
neur <- strtoi(neur)
result[neur,nameVar]=gruposCluster[neur,'cluster2']
}
return(result)
}
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
print(unionClusters)
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(result)){
neur <- result[row,'neurona']
neur <- strtoi(neur)
print(neur)
result[neur,nameVar]=gruposCluster[neur,'cluster2']
}
return(result)
}
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(dfAUnir)){
neur <- dfAUnir[row,'neurona']
neur <- strtoi(neur)
print(neur)
group <- gruposCluster[neur,'cluster2']
print(group)
}
return(result)
}
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(dfAUnir)){
neur <- dfAUnir[row,'neurona']
neur <- strtoi(neur)
print(neur)
group <- gruposCluster[neur,'cluster2']
result[row,nameVar] <- group
}
return(result)
}
unionClusters <- unirCluster(matrizaux,matrizcluster2aux,2)
print(unionClusters)
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(dfAUnir)){
neur <- dfAUnir[row,'neurona']
neur <- strtoi(neur)
print(neur)
group <- gruposCluster[neur,1]
result[row,nameVar] <- group
}
return(result)
}
print(unionClusters)
datasetcluster2aux=as.data.frame(cluster2)
datasetcluster3aux=as.data.frame(cluster3)
datasetcluster4aux=as.data.frame(cluster4)
unionClusters <- unirCluster(matrizaux,datasetcluster3aux,3)
print(unionClusters)
unionClusters <- unirCluster(unionClusters,matrizcluster2aux,2)
unionClusters <- unirCluster(unionClusters,datasetcluster4aux,4)
print(unionClusters)
rm(list = ls())
#cargamos los packetes
library(kohonen)
library(dplyr)
library(aweSOM)
#primeramente ir al directorio con los datos
directory <- paste(dirname(getwd()),'/GenerateGroups',sep='')
directory <- paste(directory,'/G01/G01_SC_22_10x10.csv',sep='')
#dependiendo de que grupo queramos utilizar cambiamos el comando anterior al grupo elegido
df <- read.csv(directory)
status <- df$status
name <- df$name
df <- select(df,-name)
df <- select(df,-status)
set.seed(23)
#se utiliza scale() para poder dimensionar bien el dataset y poder entrenar
dfScaled <- scale(df,center=T,scale=T)
#inicializamos la red con la que entrenaremos
redInit <- somInit(dfScaled,10,10,"random")
#ahora entrenamos la red
G01SOM <- som(dfScaled, grid = somgrid(10,10,"hexagonal"), rlen = 1000,init = redInit)
#representamos la red
purple.fade <- function(n){
return(rgb(0,0,0.2,alpha=seq(0,1,1/n)))}
plot(G01SOM, type="count", shape = "straight", palette.name = purple.fade)
plot(G01SOM, type="dist.neighbours", shape = "straight")
#Vemos que clusters ha creado la red
distancesSOM <- dist(getCodes(G01SOM,1))
cluster <- hclust(distancesSOM)
plot(cluster,hang=-1,labels=F)
#ahora probamos que secciones crea para 2, 3 y 4 clusters
cluster2 <- cutree(cluster, k=2)
cluster3 <- cutree(cluster, k=3)
cluster4 <- cutree(cluster, k=4)
#representamos cada uno de ellos para estudiar si existen diferencias a la hora de hacer grupos
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1")[cluster2], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen")[cluster3], shape = "straight")
plot(G01SOM,type="mapping",bgcol=c("steelblue1","sienna1","yellowgreen","red")[cluster4], shape = "straight")
#volvemos a juntar las variables de name y status junto a que neurona ha sido asignada dicho registro
aux <- cbind(name,G01SOM$unit.classif)
aux <- cbind(aux,status)
#le asignamos un nombre a la columna de la neurona
colnames(aux) <- c('name','neurona','status')
#creamos los datasets con los que trabajaremos para que resulte mas sencillo
datasetaux=as.data.frame(aux)
datasetcluster2aux=as.data.frame(cluster2)
datasetcluster3aux=as.data.frame(cluster3)
datasetcluster4aux=as.data.frame(cluster4)
# y una funciÃ³n que opere sobre los dataset y una los grupos con los datos
unirCluster <- function(dfAUnir,gruposCluster,nClusters){
result <- dfAUnir
nameVar <- paste(nClusters,'Nclusters',sep='')
result[nameVar] <- NA
for (row in 1:nrow(dfAUnir)){
neur <- dfAUnir[row,'neurona']
neur <- strtoi(neur)
group <- gruposCluster[neur,1]
result[row,nameVar] <- group
}
return(result)
}
#ahora unimos los 3 clusters al dataset formado anteriormente
unionClusters <- unirCluster(datasetaux,datasetcluster2aux,2)
unionClusters <- unirCluster(unionClusters,datasetcluster3aux,3)
unionClusters <- unirCluster(unionClusters,datasetcluster4aux,4)
print(unionClusters)
write.table(unionClusters, file = "D:\TFGParkinson\OxfordDataset\Code\GenerateGroups\G01\G01.txt", sep = ",",
write.table(unionClusters, file = "D:\TFGParkinson\OxfordDataset\Code\GenerateGroups\G01\G01.txt", sep = ",",row.names = FALSE, col.names = TRUE)
write.table(unionClusters,:\TFGParkinson\OxfordDataset\Code\GenerateGroups\G01\G01.txt", sep = ",",row.names = FALSE, col.names = TRUE)
write.table(unionClusters,file='D:\TFGParkinson\OxfordDataset\Code\GenerateGroups\G01')
write.table(unionClusters,file=
'D:\TFGParkinson\OxfordDataset\Code\GenerateGroups\G01\G01.txt',
write.table(unionClusters, file = "D:/TFGParkinson/OxfordDataset/Code/GenerateGroups/G01/G01.txt", sep = ",",row.names = FALSE, col.names = TRUE)
